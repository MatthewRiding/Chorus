import numpy as np
from PySide6.QtWidgets import QMainWindow, QMessageBox
from PySide6.QtGui import QAction, QIcon, QShortcut
from PySide6.QtCore import QThreadPool
from classdefs.modtfmworker import TFMWorker
from functions.modconvertvtonm import convert_quartet_v_to_nm

from qtdesigner.mainui.UI_chorusmain import Ui_MainWindow
from qtdesigner.dialogs.moddialogfileimportparamsfmclp import DialogImportFMCLP
from qtdesigner.dialogs.moddialogtfmparametersfmclp import DialogTFMParamsFMCLP
from classdefs.modtfmimageslistmodel import ListModelTFMImages
from classdefs.modlistedtfmimage import ListedTFMImage
from classdefs.modpcmviewer import PCMViewer
from classdefs.modcheopsviewer import CheopsViewer
from classdefs.modfullmatrix import FullMatrixLinearPeriodic
from classdefs.modisochronmanager import IsochronManager
from functions.moddetrendfmc3d import detrend_fmc_3d
from functions.modextractpcm import extract_pcm
from functions.modcalculateanglematrix import calculate_pixel_ray_angle_matrix_deg
from corevariables.modfiletypeloading import dict_loading_functions


class ChorusMainWindow(QMainWindow, Ui_MainWindow):
    """PySide6 class definition for the main window of the Chorus GUI."""

    def __init__(self):
        super().__init__()
        # Call the 'setupUi' method built into UiMainWindow, auto-generated by Qt Designer:
        self.setupUi(self)

        # Set window title:
        self.setWindowTitle('Chorus')

        # Initialise instance variables with default values:
        self.gen_index = 0
        self.det_index = 0
        self.time_index = 0
        self.time_us = 0
        self.full_matrix = FullMatrixLinearPeriodic(displacements_3d_nm=np.zeros(shape=(1000, 64, 64)),
                                                    t_min_us=-1, t_max_us=10)
        self.displacements_3d_displayed_nm = np.zeros(shape=(1000, 64, 64))
        self.selected_tfm_image = None
        self.pixel_selected = False
        self.pixel_coords_tuple_m = None
        self.delay_matrix_s = None
        self.tfm_constructor_previous = None
        self.pcm_viewer_widget = None
        self.cheops_viewer_widget = None
        self.isochron_manager = IsochronManager(self.tfm_image_widget_2D)

        # Create a QThreadPool to enable parallel processing:
        self.threadpool = QThreadPool()

        # Create a new list model for the TFM images:
        self.list_model_tfm_images = ListModelTFMImages()
        # Set the new model as the model for the listView:
        self.listView_tfm_images.setModel(self.list_model_tfm_images)

        # Add icons to buttons:
        self.pushButton_add_tfm_image.setIcon(QIcon('graphicfiles/plus.png'))
        self.pushButton_delete_tfm_image.setIcon(QIcon('graphicfiles/delete.png'))

        # Disable interactive widgets by default, since no data has been loaded:
        self.disable_sliders()
        self.disable_tfm_buttons()
        self.pushButton_display_unfiltered.setEnabled(False)
        self.doubleSpinBox_colormap_max_abs_pm.setEnabled(False)
        self.doubleSpinBox_time_us.setEnabled(False)
        self.spinBox_det_index.setEnabled(False)
        self.spinBox_gen_index.setEnabled(False)

        # Disable the lineEdit for the time doubleSpinBox to prevent the user entering invalid time points:
        self.doubleSpinBox_time_us.lineEdit().setReadOnly(True)

        # Customize B-scan view widget instances:
        self.b_scan_view_widget_iso_gen.mpl_canvas.ax.set_xlabel('Detection index')
        self.b_scan_view_widget_iso_det.label_title.setText('  Iso-det  ')
        self.b_scan_view_widget_iso_gen.label_title.setText('  Iso-gen  ')

        # Create actions:
        # Action to open a .mat file:
        action_open = QAction('Open FMC...', parent=self)
        action_open.setStatusTip('Open a full matrix capture file from one of the accepted formats '
                                 '(.mat, .npy, .txt).')
        action_open.triggered.connect(self.open_fmclp)
        # Action to toggle the pixel contributions matrix (pcm) viewer window:
        self.action_toggle_pcm_viewer = QAction('Pixel contributions matrix viewer', parent=self)
        self.action_toggle_pcm_viewer.setCheckable(True)
        self.action_toggle_pcm_viewer.triggered.connect(self.toggle_pcm_viewer)
        # Action to toggle the Cheops pyramid viewer window:
        self.action_toggle_cheops_viewer = QAction('Cheops viewer', parent=self)
        self.action_toggle_cheops_viewer.setCheckable(True)
        self.action_toggle_cheops_viewer.triggered.connect(self.toggle_cheops_viewer)

        # Create menus:
        self.menu_windows = self.menubar.addMenu('Windows')

        # Add actions to menus:
        self.menu_file.addAction(action_open)
        self.menu_windows.addActions([self.action_toggle_pcm_viewer, self.action_toggle_cheops_viewer])

        # Create shortcuts:
        self.shortcut_ctrl_n = QShortcut('Ctrl+N', self)

        # Connect signals to slots:
        self.slider_det_index.valueChanged.connect(self.det_index_changed_by_slider)
        self.spinBox_det_index.valueChanged.connect(self.det_index_changed_by_spinbox)
        self.slider_gen_index.valueChanged.connect(self.gen_index_changed_by_slider)
        self.spinBox_gen_index.valueChanged.connect(self.gen_index_changed_by_spinbox)
        self.slider_time_index.valueChanged.connect(self.time_index_changed_by_slider)
        self.doubleSpinBox_time_us.valueChanged.connect(self.time_value_changed_by_spinbox)
        self.doubleSpinBox_colormap_max_abs_pm.valueChanged.connect(self.colormap_max_abs_changed)
        self.pushButton_add_tfm_image.clicked.connect(self.add_tfm_button_clicked)
        self.listView_tfm_images.selectionModel().selectionChanged.connect(self.tfm_image_list_view_selection_changed)
        self.pushButton_display_unfiltered.toggled.connect(self.button_display_unfiltered_toggled)
        self.pushButton_delete_tfm_image.clicked.connect(self.delete_scan_button_pressed)
        self.tfm_image_widget_2D.pixel_clicked.connect(self.tfm_pixel_clicked)
        self.iso_time_plot_widget.pixel_clicked.connect(self.isochron_manager.iso_time_click_response)
        self.iso_time_plot_widget.canvas_scroll.connect(self.time_value_changed_by_iso_time_scroll)
        self.shortcut_ctrl_n.activated.connect(self.shortcut_ctrl_n_activated)

    def det_index_changed_by_slider(self, index):
        # Update spinBox to match, without firing the spinBox's valueChanged Signal:
        self.spinBox_det_index.blockSignals(True)
        self.spinBox_det_index.setValue(index)
        self.spinBox_det_index.blockSignals(False)
        self.det_index_changed(index)

    def det_index_changed_by_spinbox(self, index):
        # Update slider to match, without firing its valueChanged Signal:
        self.slider_det_index.blockSignals(True)
        self.slider_det_index.setValue(index)
        self.slider_det_index.blockSignals(False)
        self.det_index_changed(index)

    def det_index_changed(self, index):
        self.det_index = index
        self.update_iso_det_plot()
        self.b_scan_view_widget_iso_det.blit_manager.blit_all_animated_artists()
        # Update the det index marker line on the iso-time plot:
        self.iso_time_plot_widget.update_det_line(self.det_index)
        self.iso_time_plot_widget.blit_manager.blit_all_animated_artists()

    def gen_index_changed_by_slider(self, index):
        # Update SpinBox to match, without firing its ValueChanged signal:
        self.spinBox_gen_index.blockSignals(True)
        self.spinBox_gen_index.setValue(index)
        self.spinBox_gen_index.blockSignals(False)
        self.gen_index_changed(index)

    def gen_index_changed_by_spinbox(self, index):
        # Update slider to match:
        self.slider_gen_index.blockSignals(True)
        self.slider_gen_index.setValue(index)
        self.slider_gen_index.blockSignals(False)
        self.gen_index_changed(index)

    def gen_index_changed(self, index):
        self.gen_index = index
        self.update_iso_gen_plot()
        self.b_scan_view_widget_iso_gen.blit_manager.blit_all_animated_artists()
        # Update the gen index marker line on the iso-time plot:
        self.iso_time_plot_widget.update_gen_line(self.gen_index)
        self.iso_time_plot_widget.blit_manager.blit_all_animated_artists()

    def time_index_changed_by_slider(self, index):
        self.time_index = index
        # Find the associated time:
        time_us = self.full_matrix.time_vector_us[index]
        # Set the spinBox to match, without firing its signals:
        self.doubleSpinBox_time_us.blockSignals(True)
        self.doubleSpinBox_time_us.setValue(time_us)
        self.doubleSpinBox_time_us.blockSignals(False)
        # Call the generic time value changed method:
        self.time_value_changed(time_us)

    def time_value_changed_by_spinbox(self, time_us):
        # The lineEdit associated with the time doubleSpinBox is disabled, and the arrow keys can only increment the
        # time value by the correct step size, therefore all time values should be valid.
        # Find the index in the time vector associated with the value set in the spinbox:
        # Using floor division (//):
        index = int((time_us - self.full_matrix.t_min_us) // self.full_matrix.period_sampling_us)
        # Set the value of the slider to match, without firing its valueChanged signal:
        self.slider_time_index.blockSignals(True)
        self.slider_time_index.setValue(index)
        self.slider_time_index.blockSignals(False)
        # Update the value of the instance variable self.time_index:
        self.time_index = index
        # Call the generic time value changed method:
        self.time_value_changed(time_us)

    def time_value_changed_by_iso_time_scroll(self, positive):
        # Get the spinbox step size:
        if positive:
            step = self.doubleSpinBox_time_us.singleStep()
        else:
            step = - self.doubleSpinBox_time_us.singleStep()

        new_time_us = self.doubleSpinBox_time_us.value() + step
        # Set spinbox value, emitting its 'valueChanged' signal on purpose:
        self.doubleSpinBox_time_us.setValue(new_time_us)

    def time_value_changed(self, time_us):
        self.time_us = time_us

        # Call the method to update the iso-time_plot:
        self.update_iso_time_plot()

        # Update the time marker lines on the two b-scans to highlight the selected time:
        self.b_scan_view_widget_iso_det.update_time_line(time_us)
        self.b_scan_view_widget_iso_gen.update_time_line(time_us)

        if self.cheops_viewer_widget:
            self.cheops_viewer_widget.update_time_plane(time_us)
            self.cheops_viewer_widget.mpl_canvas.draw()

        # Update the isochron:
        self.isochron_manager.selected_time_changed(self.time_us * 10**-6)

        # Blit changed widgets:
        self.iso_time_plot_widget.blit_manager.blit_all_animated_artists()
        self.b_scan_view_widget_iso_gen.blit_manager.blit_all_animated_artists()
        self.b_scan_view_widget_iso_det.blit_manager.blit_all_animated_artists()

    def open_fmclp(self):
        # Launch a dialog window to ask the user for the file import and display parameters:
        (provided, description, file_path_mat,
         file_extension, t_min_us, t_max_us, detrend_tf) = self.request_file_import_params()

        if provided:
            # The user has provided file import parameters and wishes to continue with the data import.
            # Load the 3d fmc a-scan displacement data (in volts).
            # Use a different loading function depending on the format of the file provided:
            loading_function = dict_loading_functions[file_extension]
            displacements_3d_v = loading_function(file_path_mat)
            # The raw displacement signals contained in the selected file are assumed to be in units of volts, output
            # from the Sound and Bright Quartet laser ultrasound detection interferometer operating in 'absolute' mode.
            # The Volt values can be converted to units of nanometers (nm) thanks to the absolute calibration of the
            # Quartet (10nm per volt):
            displacements_3d_nm = convert_quartet_v_to_nm(displacements_3d_v)

            # If requested, de-trend the displacements_3d_nm and overwrite:
            if detrend_tf:
                displacements_3d_nm = detrend_fmc_3d(displacements_3d_nm)

            # Create a new instance of the FullMatrixLinearPeriodic class:
            self.full_matrix = FullMatrixLinearPeriodic(displacements_3d_nm, t_min_us, t_max_us)

            # Update everything to reflect the new fmclp data set:
            self.macro_new_fmclp_dataset()

            # Enable interactive widgets associated with the b-scan plots and iso-t plot:
            self.enable_interactive_widgets_b_scans_and_iso_t()

            # Enable add TFM button:
            self.pushButton_add_tfm_image.setEnabled(True)

    def macro_new_fmclp_dataset(self):
        """Update everything to reflect the new fmclp data set:"""
        self.displacements_3d_displayed_nm = self.full_matrix.displacements_3d_nm

        # Update plot axes based on the new number of array elements and time vector:
        self.b_scan_view_widget_iso_det.update_axes(self.full_matrix.n_elements,
                                                    self.full_matrix.t_min_us, self.full_matrix.t_max_us)
        self.b_scan_view_widget_iso_gen.update_axes(self.full_matrix.n_elements,
                                                    self.full_matrix.t_min_us, self.full_matrix.t_max_us)
        self.iso_time_plot_widget.update_axes(self.full_matrix.n_elements)
        if self.pcm_viewer_widget:
            self.pcm_viewer_widget.update_axes(self.full_matrix.n_elements)
            self.pcm_viewer_widget.re_draw_mplcanvas()
        if self.cheops_viewer_widget:
            self.cheops_viewer_widget.update_axes(self.full_matrix.n_elements,
                                                  self.full_matrix.t_min_us, self.full_matrix.t_max_us)
            self.cheops_viewer_widget.mpl_canvas.draw()

        # Update and re-set controls (sliders and spin boxes) for time, gen and det indices:
        self.update_and_reset_time_gen_det_controls()

        # Visualise the FMC on the plots:
        # Use min and max to set colormaps:
        self.set_colormap_limits_to_displacement_max_abs()
        # Update displayed data:
        self.update_iso_det_plot()
        self.b_scan_view_widget_iso_det.mpl_canvas.draw()
        self.update_iso_gen_plot()
        self.b_scan_view_widget_iso_gen.mpl_canvas.draw()
        self.update_iso_time_plot()
        self.iso_time_plot_widget.mpl_canvas.draw()

    def request_file_import_params(self):
        # Open a dialog to request the file import parameters:
        dialog_file_import_params = DialogImportFMCLP(parent=self)
        dialog_file_import_params.exec()
        # When the dialog has either been accepted or rejected:
        # Boolean showing whether the user clicked 'accept' or 'cancel':
        provided = dialog_file_import_params.result()
        # Other returned parameters:
        description = dialog_file_import_params.description_string
        file_path = dialog_file_import_params.file_path
        file_extension = dialog_file_import_params.file_extension
        t_min = dialog_file_import_params.t_min_us
        t_max = dialog_file_import_params.t_max_us
        detrend_tf = dialog_file_import_params.checkBox_detrend.isChecked()

        return provided, description, file_path, file_extension, t_min, t_max, detrend_tf

    def update_iso_det_plot(self):
        # Update the displacement data used in the iso-det B-scan colormap:
        displacements_b_scan_iso_det_nm = self.displacements_3d_displayed_nm[:, self.det_index, :]
        self.b_scan_view_widget_iso_det.update_b_scan_display(displacements_b_scan_iso_det_nm)
        # If a pixel is selected, update the delays shown:
        if self.selected_tfm_image and self.selected_tfm_image.complete and self.pixel_selected:
            delay_vector_iso_det = self.delay_matrix_s[self.det_index, :]
            self.b_scan_view_widget_iso_det.update_delays(delay_vector_iso_det)

    def update_iso_gen_plot(self):
        # Update the displacement data used in the iso-gen B-scan colormap:
        displacements_b_scan_iso_gen_nm = self.displacements_3d_displayed_nm[:, :, self.gen_index]
        self.b_scan_view_widget_iso_gen.update_b_scan_display(displacements_b_scan_iso_gen_nm)
        # If a pixel is selected, update the delays shown:
        if self.selected_tfm_image and self.selected_tfm_image.complete and self.pixel_selected:
            delay_vector_iso_gen = self.delay_matrix_s[:, self.gen_index]
            self.b_scan_view_widget_iso_gen.update_delays(delay_vector_iso_gen)

    def update_iso_time_plot(self):
        # Update the displacement data used in the iso-time colormap:
        displacements_iso_time_slice_nm = self.displacements_3d_displayed_nm[self.time_index, :, :]
        self.iso_time_plot_widget.update_iso_time_slice_display(displacements_iso_time_slice_nm)
        # If a pixel is selected, update the highlighted nearest A-scans:
        if self.selected_tfm_image and self.selected_tfm_image.complete and self.pixel_selected:
            self.iso_time_plot_widget.update_nearest_a_scans(self.delay_matrix_s,
                                                             self.full_matrix.time_vector_us[self.time_index])

    def disable_sliders(self):
        self.slider_det_index.setEnabled(False)
        self.slider_gen_index.setEnabled(False)
        self.slider_time_index.setEnabled(False)

    def update_and_reset_time_gen_det_controls(self):
        # Update step for time navigation via the doubleSpinBox:
        self.update_time_spinbox_step()
        # Update time doubleSpinBox limits:
        self.update_time_spinbox_limits()
        # Update slider limits:
        self.update_slider_limits()
        # Update gen and det index spinbox limits:
        self.update_gen_and_det_spinbox_limits()
        # Re-set time, gen and det indices:
        self.reset_time_gen_and_det_values()

    def update_time_spinbox_step(self):
        # Set sampling period as step size for time doubleSpinBox:
        self.doubleSpinBox_time_us.setSingleStep(self.full_matrix.period_sampling_us)

    def update_time_spinbox_limits(self):
        self.doubleSpinBox_time_us.setMinimum(self.full_matrix.t_min_us)
        self.doubleSpinBox_time_us.setMaximum(self.full_matrix.t_max_us)

    def update_slider_limits(self):
        # Update slider limits:
        # Remember, Python is zero-indexed.  The first element is element 0, and the last is element n_tx-1.
        self.slider_det_index.setMaximum(self.full_matrix.n_elements - 1)
        self.slider_gen_index.setMaximum(self.full_matrix.n_elements - 1)
        self.slider_time_index.setMaximum(self.full_matrix.n_samples - 1)

    def update_gen_and_det_spinbox_limits(self):
        # Python is zero-indexed: gen and det indices go from 0 to (n_tx - 1):
        self.spinBox_gen_index.setMaximum(self.full_matrix.n_elements - 1)
        self.spinBox_det_index.setMaximum(self.full_matrix.n_elements - 1)

    def reset_time_gen_and_det_values(self):
        # Set time to the minimum of the new time vector, without emitting signals:
        self.time_index = 0
        self.slider_time_index.blockSignals(True)
        self.slider_time_index.setValue(0)
        self.slider_time_index.blockSignals(False)
        self.doubleSpinBox_time_us.blockSignals(True)
        self.doubleSpinBox_time_us.setValue(self.full_matrix.t_min_us)
        self.doubleSpinBox_time_us.blockSignals(False)

        # Set gen and det indices to 0, without emitting signals:
        self.slider_gen_index.blockSignals(True)
        self.slider_gen_index.setValue(0)
        self.slider_gen_index.blockSignals(False)
        self.slider_det_index.blockSignals(True)
        self.slider_det_index.setValue(0)
        self.slider_det_index.blockSignals(False)
        self.spinBox_gen_index.blockSignals(True)
        self.spinBox_gen_index.setValue(0)
        self.spinBox_gen_index.blockSignals(False)
        self.spinBox_det_index.blockSignals(True)
        self.spinBox_det_index.setValue(0)
        self.spinBox_det_index.blockSignals(False)

    def c_min_changed(self, u_min_nm):
        self.set_colormap_u_min_for_all_images(u_min_nm)
        self.update_raw_displacement_images()

    def c_max_changed(self, u_max_nm):
        self.set_colormap_u_max_for_all_widgets(u_max_nm)
        self.update_raw_displacement_images()

    def colormap_max_abs_changed(self, colormap_max_abs_pm):
        # Convert picometres to nanometres:
        colormap_max_abs_nm = colormap_max_abs_pm / 1000
        # Use positive value as vmax of clims, use negative value as vmin:
        colormap_u_min_nm = - colormap_max_abs_nm
        colormap_u_max_nm = colormap_max_abs_nm
        # Update clims of all images:
        self.set_colormap_u_min_for_all_images(colormap_u_min_nm)
        self.set_colormap_u_max_for_all_widgets(colormap_u_max_nm)
        self.update_raw_displacement_images()

    def set_colormap_u_min_for_all_images(self, colormap_u_min_nm):
        self.iso_time_plot_widget.axes_image.set_clim(vmin=colormap_u_min_nm)
        self.b_scan_view_widget_iso_det.axes_image.set_clim(vmin=colormap_u_min_nm)
        self.b_scan_view_widget_iso_gen.axes_image.set_clim(vmin=colormap_u_min_nm)
        if self.pcm_viewer_widget:
            self.pcm_viewer_widget.new_c_min(colormap_u_min_nm)

    def set_colormap_u_max_for_all_widgets(self, colormap_u_max_nm):
        self.iso_time_plot_widget.axes_image.set_clim(vmax=colormap_u_max_nm)
        self.b_scan_view_widget_iso_det.axes_image.set_clim(vmax=colormap_u_max_nm)
        self.b_scan_view_widget_iso_gen.axes_image.set_clim(vmax=colormap_u_max_nm)
        if self.pcm_viewer_widget:
            self.pcm_viewer_widget.new_c_max(colormap_u_max_nm)

    def set_colormap_limits_to_displacement_max_abs(self):
        # Set the colormap limits to be + and - the maximum of the absolute values of displacement in the dataset:
        displacement_max_abs_nm = np.max(np.abs(self.displacements_3d_displayed_nm))

        self.set_colormap_u_min_for_all_images(- displacement_max_abs_nm)
        self.set_colormap_u_max_for_all_widgets(displacement_max_abs_nm)

        # Display the new colormap max abs displacement value in the DoubleSpinBox, muting its signals to prevent
        # triggering connected slots:
        self.doubleSpinBox_colormap_max_abs_pm.blockSignals(True)
        self.doubleSpinBox_colormap_max_abs_pm.setValue(displacement_max_abs_nm * 1000)
        self.doubleSpinBox_colormap_max_abs_pm.blockSignals(False)

    def update_raw_displacement_images(self):
        self.iso_time_plot_widget.blit_manager.blit_all_animated_artists()
        self.b_scan_view_widget_iso_det.blit_manager.blit_all_animated_artists()
        self.b_scan_view_widget_iso_gen.blit_manager.blit_all_animated_artists()
        if self.pcm_viewer_widget:
            self.pcm_viewer_widget.re_draw_pcm_mplcanvas()

    def disable_tfm_buttons(self):
        self.pushButton_add_tfm_image.setEnabled(False)
        self.pushButton_delete_tfm_image.setEnabled(False)

    def add_tfm_button_clicked(self):
        # Open a dialog to request a new set of TFM parameters from the user:
        accepted, tfm_constructor = self.request_tfm_params()

        if accepted:
            self.run_tfm_job(tfm_constructor)

    def request_tfm_params(self):
        # Open a dialog to request the TFM parameters:
        dialog_tfm_params = DialogTFMParamsFMCLP(n_elements=self.full_matrix.n_elements,
                                                 frequency_sampling_hz=self.full_matrix.frequency_sampling_hz,
                                                 parent=self, tfm_constructor_previous=self.tfm_constructor_previous)
        dialog_tfm_params.exec()
        # When the dialog has either been accepted or rejected:
        # Boolean showing whether the user clicked 'accept' or 'cancel':
        accepted = dialog_tfm_params.result()
        # If accepted, dialog_tfm_params.tfm_constructor will be a TFMConstructor object containing all the parameters
        # needed.  If rejected, dialog_tfm_params.tfm_constructor will return 'None'.
        tfm_constructor = dialog_tfm_params.tfm_constructor
        # Update the 'previous' tfm params for use if the dialog is called again:
        self.tfm_constructor_previous = tfm_constructor
        return accepted, tfm_constructor

    def run_tfm_job(self, tfm_constructor):
        # When the user submits their new TFM parameters, we need to start a QRunnable to compute the TFM:
        tfm_worker = TFMWorker(full_matrix=self.full_matrix, tfm_constructor=tfm_constructor)

        # Wire the signals emitted by the parallel operation to slots:
        tfm_worker.signals.progress.connect(self.worker_progress_detected)
        tfm_worker.signals.result.connect(self.worker_result_detected)
        tfm_worker.signals.finished.connect(self.worker_finished_detected)

        # Create a new instance of ListedTFMImage and add it to the list model:
        self.list_model_tfm_images.dict_listed_images[tfm_worker.worker_id] = ListedTFMImage(tfm_worker.worker_id,
                                                                                             tfm_constructor,
                                                                                             self.full_matrix.n_elements)

        # Run the TFM_worker in the threadpool:
        self.threadpool.start(tfm_worker)

    def worker_progress_detected(self, data_tuple):
        # A worker has transmitted the 'progress' signal.  The data_tuple contains two elements:
        worker_id, progress_string = data_tuple

        # Update the progress_string of the associated ListedTFMImage instance:
        self.list_model_tfm_images.dict_listed_images[worker_id].progress_string = progress_string

        # Trigger the ListView to update:
        self.list_model_tfm_images.layoutChanged.emit()

    def worker_result_detected(self, data_tuple):
        # A worker has transmitted the 'result' signal.  The data_tuple contains two elements:
        worker_id, summed_displacement_image_complex_nm, fmc_3d_filtered = data_tuple

        # Pin the returned complex image & filtered FMC to the associated ListedTFMImage instance:
        self.list_model_tfm_images.dict_listed_images[worker_id].new_image_complex(summed_displacement_image_complex_nm)
        self.list_model_tfm_images.dict_listed_images[worker_id].fmc_3d_filtered = fmc_3d_filtered

    def worker_finished_detected(self, worker_id):
        # A worker has transmitted the 'finished' signal.
        # Call the 'completed()' method for the associated ListedTFMImage instance:
        self.list_model_tfm_images.dict_listed_images[worker_id].completed()

        # Trigger the ListView to update:
        self.list_model_tfm_images.layoutChanged.emit()

    def tfm_image_list_view_selection_changed(self, item_selection):
        # The selection could be 'None':
        if item_selection:
            # A valid index with a corresponding ListedTFMImage instance has been selected:
            indexes = item_selection.indexes()
            index = indexes[0]
            # Use 'index' to obtain the key (worker ID) for the selected TFM image:
            key = list(self.list_model_tfm_images.dict_listed_images.keys())[index.row()]
            self.selected_tfm_image = self.list_model_tfm_images.dict_listed_images[key]

            if self.selected_tfm_image.complete:
                self.complete_tfm_image_selected()
            else:
                self.clear_and_deactivate_tfm_image_area()
        else:
            # The selection has changed to 'None':
            self.clear_and_deactivate_tfm_image_area()

        # Update the IsochronManager, whether the new selection is 'None' or a valid ListedTFMImage:
        self.isochron_manager.update_selected_tfm_image(self.selected_tfm_image)

    def complete_tfm_image_selected(self):
        # The user has clicked on a complete TFM image:

        # Clear the pixel selection and delay laws:
        if self.pixel_selected:
            self.pixel_selected = False
            self.tfm_image_widget_2D.clear_pixel_cursor()
            self.clear_cheops_data()

        # Prompt the tfm image widget to update:
        self.tfm_image_widget_2D.new_listed_tfm_image(self.selected_tfm_image)

        # If the selected TFM image used filtering, display the filtered FMC on the B-scan and iso-time widgets:
        if self.selected_tfm_image.tfm_constructor.filter_spec:
            self.macro_swap_displayed_fmc(self.selected_tfm_image.fmc_3d_filtered)
            # Enable the 'display unfiltered' button:
            self.pushButton_display_unfiltered.setEnabled(True)
        else:
            # The selected TFM image did not use filtering.
            # Display the original, unfiltered FMC:
            self.macro_swap_displayed_fmc(self.full_matrix.displacements_3d_nm)
            # Disable the 'display unfiltered' button:
            self.pushButton_display_unfiltered.setEnabled(False)

        # Enable the 'delete tfm image' button:
        self.pushButton_delete_tfm_image.setEnabled(True)

    def clear_cheops_data(self):
        # Clear Cheops delay times & hide delay markers on all raw data plots:
        self.b_scan_view_widget_iso_det.clear_delay_times_and_hide()
        self.b_scan_view_widget_iso_det.blit_manager.blit_all_animated_artists()
        self.b_scan_view_widget_iso_gen.clear_delay_times_and_hide()
        self.b_scan_view_widget_iso_gen.blit_manager.blit_all_animated_artists()
        self.iso_time_plot_widget.clear_nearest_a_scan_highlights_and_hide()
        self.iso_time_plot_widget.blit_manager.blit_all_animated_artists()
        if self.cheops_viewer_widget:
            self.cheops_viewer_widget.hide_cheops_pyramid()

    def clear_and_deactivate_tfm_image_area(self):
        # The user has clicked on a TFM image that is still processing:
        # Display nothing on the TFM image plot:
        self.tfm_image_widget_2D.clear_and_deactivate_tfm_image_area()
        # Disable the delete tfm image button:
        self.pushButton_delete_tfm_image.setEnabled(False)

    def macro_swap_displayed_fmc(self, fmc_3d):
        # Swap the c_data on the B-scan widgets and iso-time widgets:
        # Update the fmc used for display:
        self.displacements_3d_displayed_nm = fmc_3d
        # Update the c_data on the B-scan plots and iso-time plot:
        self.update_iso_det_plot()
        self.b_scan_view_widget_iso_det.blit_manager.blit_all_animated_artists()
        self.update_iso_gen_plot()
        self.b_scan_view_widget_iso_gen.blit_manager.blit_all_animated_artists()
        self.update_iso_time_plot()
        self.iso_time_plot_widget.blit_manager.blit_all_animated_artists()

    def button_display_unfiltered_toggled(self, checked):
        if checked:
            # Display the unfiltered FMC:
            self.macro_swap_displayed_fmc(self.full_matrix.displacements_3d_nm)
        else:
            # Display the filtered FMC:
            self.macro_swap_displayed_fmc(self.selected_tfm_image.fmc_3d_filtered)

    def enable_interactive_widgets_b_scans_and_iso_t(self):
        self.slider_det_index.setEnabled(True)
        self.slider_gen_index.setEnabled(True)
        self.slider_time_index.setEnabled(True)
        self.doubleSpinBox_colormap_max_abs_pm.setEnabled(True)
        self.doubleSpinBox_time_us.setEnabled(True)
        self.spinBox_gen_index.setEnabled(True)
        self.spinBox_det_index.setEnabled(True)

    def delete_scan_button_pressed(self):
        # Delete the data associated with the selected tfm image, if there is one selected and it is 'complete':
        if self.selected_tfm_image:
            if self.selected_tfm_image.complete:
                # Ask the user for confirmation with a dialog:
                # Get the display string of the selected TFM image to use in the question:
                selected_image_name = self.selected_tfm_image.get_display_string()
                button_chosen = QMessageBox.question(self, 'Confirm delete',
                                                     f'Are you sure you want to delete {selected_image_name}?')

                if button_chosen == QMessageBox.Yes:
                    # Delete the corresponding ListedTFMImage instance in the model dictionary:
                    key = self.selected_tfm_image.worker_id
                    del self.list_model_tfm_images.dict_listed_images[key]
                    # Emit the 'layout changed' signal from the list model to prompt the list view to update:
                    self.list_model_tfm_images.layoutChanged.emit()
                    # Clear the selection model of the ListView:
                    self.listView_tfm_images.clearSelection()
                else:
                    # The user changed their mind and no longer wants to delete the selected TFM image.
                    pass

    def tfm_pixel_clicked(self, xz_coords_m_tuple):
        # Respond differently depending on tuple contents:
        if xz_coords_m_tuple[0] is None:
            # Clear the Cheops data from all relevant widgets:
            self.clear_cheops_data()
        else:
            # Only calculate & display delay laws for this pixel if there is currently a valid selected listed TFM image:
            if self.selected_tfm_image:
                if self.selected_tfm_image.complete:
                    # Store pixel co-ordinates:
                    self.pixel_coords_tuple_m = xz_coords_m_tuple
                    x_pixel_m, z_pixel_m = xz_coords_m_tuple
                    self.pixel_selected = True

                    # Get the send and receive leg travel time calculation functions:
                    wave_type_send = self.selected_tfm_image.tfm_constructor.wave_type_send
                    wave_type_receive = self.selected_tfm_image.tfm_constructor.wave_type_receive
                    calculate_delay_times_single_pixel_all_el_send_s = wave_type_send.func_calculate_delay_times_single_pixel_all_el_s
                    calculate_delay_times_single_pixel_all_el_receive_s = wave_type_receive.func_calculate_delay_times_single_pixel_all_el_s

                    # Calculate the send delays for all elements:
                    send_delays_all_el_s = calculate_delay_times_single_pixel_all_el_send_s(x_pixel_m, z_pixel_m,
                                                                                            self.selected_tfm_image.tfm_constructor)
                    # Calculate the receive delays for all elements:
                    receive_delays_all_el_s = calculate_delay_times_single_pixel_all_el_receive_s(x_pixel_m, z_pixel_m,
                                                                                                  self.selected_tfm_image.tfm_constructor)

                    # Use np.meshgrid to repeat the send and receive delay vectors into arrays:
                    send_delays_matrix_s, receive_delays_matrix_s = np.meshgrid(send_delays_all_el_s, receive_delays_all_el_s)

                    # Sum the send and receive delay matrices to obtain an n_elements by n_elements matrix of delays:
                    self.delay_matrix_s = send_delays_matrix_s + receive_delays_matrix_s

                    # Mask delay law based on gen and det mask_specs:
                    if self.selected_tfm_image.tfm_constructor.mask_spec_gen or self.selected_tfm_image.tfm_constructor.mask_spec_det:
                        # Get gen mask:
                        if self.selected_tfm_image.tfm_constructor.mask_spec_gen:
                            mask_spec_gen = self.selected_tfm_image.tfm_constructor.mask_spec_gen
                            # Apply mask to the delay matrix based on send ray angle:
                            gen_angle_matrix_deg = calculate_pixel_ray_angle_matrix_deg(x_pixel_m, z_pixel_m,
                                                                                        self.selected_tfm_image.x_gen_matrix_m)
                            # Use the logic of the chosen mask behaviour:
                            numpy_masking_function_gen = mask_spec_gen.mask_behaviour.numpy_masking_function
                            gen_angle_matrix_masked = numpy_masking_function_gen(gen_angle_matrix_deg,
                                                                                 mask_spec_gen.mask_angle_deg)
                            mask_matrix_gen = np.ma.getmask(gen_angle_matrix_masked)
                        else:
                            mask_matrix_gen = np.ma.nomask

                        # Get det mask:
                        if self.selected_tfm_image.tfm_constructor.mask_spec_det:
                            mask_spec_det = self.selected_tfm_image.tfm_constructor.mask_spec_det
                            # Apply mask to the delay matrix based on send ray angle:
                            det_angle_matrix_deg = calculate_pixel_ray_angle_matrix_deg(x_pixel_m, z_pixel_m,
                                                                                        self.selected_tfm_image.x_det_matrix_m)
                            # Use the logic of the chosen mask behaviour:
                            numpy_masking_function_det = mask_spec_det.mask_behaviour.numpy_masking_function
                            det_angle_matrix_masked = numpy_masking_function_det(det_angle_matrix_deg,
                                                                                 mask_spec_det.mask_angle_deg)
                            mask_matrix_det = np.ma.getmask(det_angle_matrix_masked)
                        else:
                            mask_matrix_det = np.ma.nomask

                        # Combine gen and det masks:
                        mask_gen_and_det = np.ma.mask_or(mask_matrix_gen, mask_matrix_det)
                        # Apply combined mask to delay matrix:
                        self.delay_matrix_s = np.ma.masked_where(mask_gen_and_det, self.delay_matrix_s, copy=False)

                    # Display the delays on the B-scan widgets:
                    self.b_scan_view_widget_iso_det.update_delays(self.delay_matrix_s[self.det_index, :])
                    self.b_scan_view_widget_iso_det.make_delays_visible()
                    self.b_scan_view_widget_iso_det.blit_manager.blit_all_animated_artists()

                    self.b_scan_view_widget_iso_gen.update_delays(self.delay_matrix_s[:, self.gen_index])
                    self.b_scan_view_widget_iso_gen.make_delays_visible()
                    self.b_scan_view_widget_iso_gen.blit_manager.blit_all_animated_artists()

                    # Highlight the A-scans whose delays are closest to the current viewing time on the iso-time widget:
                    self.iso_time_plot_widget.update_nearest_a_scans(self.delay_matrix_s,
                                                                     self.full_matrix.time_vector_us[self.time_index])
                    self.iso_time_plot_widget.make_nearest_a_scans_visible()
                    self.iso_time_plot_widget.blit_manager.blit_all_animated_artists()

                    # If the pcm viewer is open, compute the pcm and update the data displayed in the PCM viewer:
                    if self.pcm_viewer_widget:
                        # The widget exists.
                        self.update_pcm_viewer_data()

                    # If the Cheops viewer widget is open, display the Cheops pyramid associated with the selected pixel:
                    if self.cheops_viewer_widget:
                        self.cheops_viewer_widget.update_cheops_pyramid(self.delay_matrix_s)
                        self.cheops_viewer_widget.mpl_canvas.draw()

    def shortcut_ctrl_n_activated(self):
        # If a pixel is selected, toggle delay law visibility on the b-scan and iso-t plots:
        if self.pixel_selected:
            self.b_scan_view_widget_iso_det.toggle_delay_visibility()
            self.b_scan_view_widget_iso_det.blit_manager.blit_all_animated_artists()
            self.b_scan_view_widget_iso_gen.toggle_delay_visibility()
            self.b_scan_view_widget_iso_gen.blit_manager.blit_all_animated_artists()
            self.iso_time_plot_widget.toggle_nearest_a_scans_visibility()
            self.iso_time_plot_widget.blit_manager.blit_all_animated_artists()

    def toggle_pcm_viewer(self):
        if self.pcm_viewer_widget:
            # The widget already exists.  Close it:
            self.pcm_viewer_widget.close()
            # Set Python reference to None:
            self.pcm_viewer_widget = None
        else:
            # The widget is not already open.  Create a new instance & show it:
            self.pcm_viewer_widget = PCMViewer()
            # Wire signals to slots:
            self.pcm_viewer_widget.pcm_viewer_closed.connect(self.slot_pcm_viewer_closed)
            # If there is a pixel selected, display the data associated with that pixel:
            if self.pixel_selected:
                self.update_pcm_viewer_data()
            # Set the colormap limits for the PCM image:
            colormap_max_abs_nm = self.doubleSpinBox_colormap_max_abs_pm.value() / 1000
            self.pcm_viewer_widget.new_c_min(-colormap_max_abs_nm)
            self.pcm_viewer_widget.new_c_max(colormap_max_abs_nm)
            # Set axes extent based on n_tx of loaded data:
            self.pcm_viewer_widget.update_axes(self.full_matrix.n_elements)
            # Open the window:
            self.pcm_viewer_widget.show()

    def slot_pcm_viewer_closed(self):
        self.action_toggle_pcm_viewer.setChecked(False)
        # Set Python reference to None:
        self.pcm_viewer_widget = None

    def update_pcm_viewer_data(self):
        # Extract the pixel contributions matrix:
        pcm_complex_nm = extract_pcm(self.displacements_3d_displayed_nm, self.full_matrix.time_vector_us,
                                     self.delay_matrix_s)
        # Update all data in the pcm viewer window:
        self.pcm_viewer_widget.macro_new_pixel_clicked(pcm_complex_nm,
                                                       self.pixel_coords_tuple_m[0], self.pixel_coords_tuple_m[1],
                                                       self.selected_tfm_image.tfm_constructor.material.critical_angle_radians,
                                                       self.selected_tfm_image.tfm_constructor.pitch_mm,
                                                       self.full_matrix.n_elements)
        # Trigger a re-draw of the pcm viewer mpl canvases:
        self.pcm_viewer_widget.re_draw_pcm_mplcanvas()

    def toggle_cheops_viewer(self):
        if self.cheops_viewer_widget:
            # The widget already exists.  Close it:
            self.cheops_viewer_widget.close()
            # Set Python reference to None:
            self.cheops_viewer_widget = None
        else:
            # The widget is not already open.  Create a new instance & show it:
            self.cheops_viewer_widget = CheopsViewer(self.full_matrix.n_elements,
                                                     self.full_matrix.t_min_us, self.full_matrix.t_max_us,
                                                     self.time_us, self.delay_matrix_s)
            # Wire signals to slots:
            self.cheops_viewer_widget.cheops_viewer_closed.connect(self.slot_cheops_viewer_closed)
            # If there is a pixel selected, display the data associated with that pixel:
            if self.pixel_selected:
                self.update_cheops_pyramid()
            # Open the window:
            self.cheops_viewer_widget.show()

    def slot_cheops_viewer_closed(self):
        self.action_toggle_cheops_viewer.setChecked(False)
        # Set Python reference to None:
        self.cheops_viewer_widget = None

    def update_cheops_pyramid(self):
        self.cheops_viewer_widget.update_cheops_pyramid(self.delay_matrix_s)
        self.cheops_viewer_widget.mpl_canvas.draw()
