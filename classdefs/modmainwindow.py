import numpy as np
from PySide6.QtWidgets import QMainWindow, QMessageBox
from PySide6.QtGui import QAction, QIcon, QShortcut
from PySide6.QtCore import QThreadPool
from classdefs.modtfmworker import TFMWorker

from qtdesigner.mainui.UI_chorusmain import Ui_MainWindow
from qtdesigner.dialogs.moddialogfileimportparamsfmclp import DialogImportFMCLPmat
from qtdesigner.dialogs.moddialogtfmparametersfmclp import DialogTFMParamsFMCLP
from classdefs.modtfmimageslistmodel import ListModelTFMImages
from classdefs.modlistedtfmimage import ListedTFMImage
from classdefs.modpcmviewer import PCMViewer
from classdefs.modcheopsviewer import CheopsViewer
from functions.modloadfmclpfrommatfile import load_fmclp_from_mat_file
from functions.moddetrendfmc3d import detrend_fmc_3d
from functions.modextractpcm import extract_pcm
from functions.modcalculategenanglematrix import calculate_gen_angle_matrix_deg
from corevariables.modwavesets import dict_wave_sets
from corevariables.modmaskbehaviours import dict_mask_behaviours


class ChorusMainWindow(QMainWindow, Ui_MainWindow):
    def __init__(self):
        super().__init__()
        # Call the 'setupUi' method built into UiMainWindow, auto-generated by Qt Designer:
        self.setupUi(self)

        # Set window title:
        self.setWindowTitle('Chorus')

        # Initialise instance variables with default values:
        self.gen_index = 0
        self.det_index = 0
        self.time_index = 0
        self.time_us = 0
        self.n_tx = 64
        self.n_samples = 1000
        self.sampling_period_us = None
        self.t_min_us = -1
        self.t_max_us = 20
        self.fmc_3d = np.zeros(shape=(self.n_samples, self.n_tx, self.n_tx))
        self.fmc_3d_displayed = np.zeros(shape=(self.n_samples, self.n_tx, self.n_tx))
        self.c_max_mv = 1
        self.c_min_mv = -1
        self.time_vector_us = None
        self.selected_tfm_image = None
        self.decibel_minimum = -10
        self.pixel_selected = False
        self.pixel_coords_tuple_m = None
        self.delay_matrix_s = None
        self.tfm_params_previous = None
        self.pcm_viewer_widget = None
        self.cheops_viewer_widget = None

        # Create a QThreadPool to enable parallel processing:
        self.threadpool = QThreadPool()

        # Create a new list model for the TFM images:
        self.list_model_tfm_images = ListModelTFMImages()
        # Set the new model as the model for the listView:
        self.listView_tfm_images.setModel(self.list_model_tfm_images)

        # Add icons to buttons:
        self.pushButton_add_tfm_image.setIcon(QIcon('graphicfiles/plus.png'))
        self.pushButton_delete_tfm_image.setIcon(QIcon('graphicfiles/delete.png'))

        # Disable interactive widgets by default, since no data has been loaded:
        self.disable_sliders()
        self.disable_tfm_buttons()
        self.pushButton_display_unfiltered.setEnabled(False)
        self.doubleSpinBox_c_min.setEnabled(False)
        self.doubleSpinBox_c_max.setEnabled(False)
        self.doubleSpinBox_dB_min.setEnabled(False)
        self.doubleSpinBox_time_us.setEnabled(False)
        self.spinBox_det_index.setEnabled(False)
        self.spinBox_gen_index.setEnabled(False)

        # Disable the lineEdit for the time doubleSpinBox to prevent the user entering invalid time points:
        self.doubleSpinBox_time_us.lineEdit().setReadOnly(True)

        # Customize B-scan view widget instances:
        self.b_scan_view_widget_iso_gen.mpl_canvas.ax.set_xlabel('Detection index')
        self.b_scan_view_widget_iso_det.label_title.setText('  Iso-det  ')
        self.b_scan_view_widget_iso_gen.label_title.setText('  Iso-gen  ')

        # Create actions:
        # Action to open a .mat file:
        action_open_mat = QAction('.mat FMC linear periodic 2D array format', parent=self)
        action_open_mat.setStatusTip('Import a .mat file for a FMC from a linear periodic array, stored in 2D array '
                                     'format.')
        action_open_mat.triggered.connect(self.open_mat_fmclp_clicked)
        # Action to toggle the pixel contributions matrix (pcm) viewer window:
        self.action_toggle_pcm_viewer = QAction('Pixel contributions matrix viewer', parent=self)
        self.action_toggle_pcm_viewer.setCheckable(True)
        self.action_toggle_pcm_viewer.triggered.connect(self.toggle_pcm_viewer)
        # Action to toggle the Cheops pyramid viewer window:
        self.action_toggle_cheops_viewer = QAction('Cheops viewer', parent=self)
        self.action_toggle_cheops_viewer.setCheckable(True)
        self.action_toggle_cheops_viewer.triggered.connect(self.toggle_cheops_viewer)

        # Create menus:
        self.menu_windows = self.menubar.addMenu('Windows')

        # Create sub-menus:
        self.menu_open = self.menu_file.addMenu('Open')

        # Add actions to menus:
        self.menu_open.addAction(action_open_mat)
        self.menu_windows.addActions([self.action_toggle_pcm_viewer, self.action_toggle_cheops_viewer])

        # Create shortcuts:
        self.shortcut_ctrl_n = QShortcut('Ctrl+N', self)

        # Connect signals to slots:
        self.slider_det_index.valueChanged.connect(self.det_index_changed_by_slider)
        self.spinBox_det_index.valueChanged.connect(self.det_index_changed_by_spinbox)
        self.slider_gen_index.valueChanged.connect(self.gen_index_changed_by_slider)
        self.spinBox_gen_index.valueChanged.connect(self.gen_index_changed_by_spinbox)
        self.slider_time_index.valueChanged.connect(self.time_index_changed_by_slider)
        self.doubleSpinBox_time_us.valueChanged.connect(self.time_value_changed_by_spinbox)
        self.doubleSpinBox_c_min.valueChanged.connect(self.c_min_changed)
        self.doubleSpinBox_c_max.valueChanged.connect(self.c_max_changed)
        self.pushButton_add_tfm_image.clicked.connect(self.add_tfm_button_clicked)
        self.listView_tfm_images.selectionModel().selectionChanged.connect(self.tfm_image_list_view_selection_changed)
        self.pushButton_display_unfiltered.toggled.connect(self.button_display_unfiltered_toggled)
        self.slider_dB_min.valueChanged.connect(self.decibel_min_changed_by_slider)
        self.doubleSpinBox_dB_min.valueChanged.connect(self.decibel_min_changed_by_spinbox)
        self.pushButton_delete_tfm_image.clicked.connect(self.delete_scan_button_pressed)
        self.tfm_image_widget_2D.pixel_clicked.connect(self.new_pixel_clicked)
        self.shortcut_ctrl_n.activated.connect(self.shortcut_ctrl_n_activated)

    def det_index_changed_by_slider(self, index):
        # Update spinBox to match, without firing the spinBox's valueChanged Signal:
        self.spinBox_det_index.blockSignals(True)
        self.spinBox_det_index.setValue(index)
        self.spinBox_det_index.blockSignals(False)
        self.det_index_changed(index)

    def det_index_changed_by_spinbox(self, index):
        # Update slider to match, without firing its valueChanged Signal:
        self.slider_det_index.blockSignals(True)
        self.slider_det_index.setValue(index)
        self.slider_det_index.blockSignals(False)
        self.det_index_changed(index)

    def det_index_changed(self, index):
        self.det_index = index
        self.update_iso_det_plot()
        self.b_scan_view_widget_iso_det.blit_manager.blit_all_animated_artists()
        # Update the det index marker line on the iso-time plot:
        self.iso_time_plot_widget.update_det_line(self.det_index)
        self.iso_time_plot_widget.blit_manager.blit_all_animated_artists()

    def gen_index_changed_by_slider(self, index):
        # Update SpinBox to match, without firing its ValueChanged signal:
        self.spinBox_gen_index.blockSignals(True)
        self.spinBox_gen_index.setValue(index)
        self.spinBox_gen_index.blockSignals(False)
        self.gen_index_changed(index)

    def gen_index_changed_by_spinbox(self, index):
        # Update slider to match:
        self.slider_gen_index.blockSignals(True)
        self.slider_gen_index.setValue(index)
        self.slider_gen_index.blockSignals(False)
        self.gen_index_changed(index)

    def gen_index_changed(self, index):
        self.gen_index = index
        self.update_iso_gen_plot()
        self.b_scan_view_widget_iso_gen.blit_manager.blit_all_animated_artists()
        # Update the gen index marker line on the iso-time plot:
        self.iso_time_plot_widget.update_gen_line(self.gen_index)
        self.iso_time_plot_widget.blit_manager.blit_all_animated_artists()

    def time_index_changed_by_slider(self, index):
        self.time_index = index
        # Find the associated time:
        time_us = self.time_vector_us[index]
        # Set the spinBox to match, without firing its signals:
        self.doubleSpinBox_time_us.blockSignals(True)
        self.doubleSpinBox_time_us.setValue(time_us)
        self.doubleSpinBox_time_us.blockSignals(False)
        # Call the generic time value changed method:
        self.time_value_changed(time_us)

    def time_value_changed_by_spinbox(self, time_us):
        # The lineEdit associated with the time doubleSpinBox is disabled, and the arrow keys can only increment the
        # time value by the correct step size, therefore all time values should be valid.
        # Find the index in the time vector associated with the value set in the spinbox:
        # Using floor division (//):
        index = int((time_us - self.t_min_us) // self.sampling_period_us)
        # Set the value of the slider to match, without firing its valueChanged signal:
        self.slider_time_index.blockSignals(True)
        self.slider_time_index.setValue(index)
        self.slider_time_index.blockSignals(False)
        # Update the value of the instance variable self.time_index:
        self.time_index = index
        # Call the generic time value changed method:
        self.time_value_changed(time_us)

    def time_value_changed(self, time_us):
        # Call the method to update the iso-time_plot:
        self.update_iso_time_plot()

        # Update the time marker lines on the two b-scans to highlight the selected time:
        self.b_scan_view_widget_iso_det.update_time_line(time_us)
        self.b_scan_view_widget_iso_gen.update_time_line(time_us)

        if self.cheops_viewer_widget:
            self.cheops_viewer_widget.update_time_plane(time_us)
            self.cheops_viewer_widget.mpl_canvas.draw()

        # Blit changed widgets:
        self.iso_time_plot_widget.blit_manager.blit_all_animated_artists()
        self.b_scan_view_widget_iso_gen.blit_manager.blit_all_animated_artists()
        self.b_scan_view_widget_iso_det.blit_manager.blit_all_animated_artists()

    def open_mat_fmclp_clicked(self):
        # Ask the user for the file import and display parameters:
        provided, description, file_path_mat, t_min_us, t_max_us, detrend_tf = self.request_file_import_params()

        # Proceed differently based on the value of 'provided':
        if provided:
            # The user has provided file import parameters and wishes to continue with the data import:
            self.fmc_3d = load_fmclp_from_mat_file(file_path_mat)

            # If requested, de-trend the fmc_3d and overwrite:
            if detrend_tf:
                self.fmc_3d = detrend_fmc_3d(self.fmc_3d)

            # Update everything to reflect the new fmclp data set:
            self.fmc_3d_displayed = self.fmc_3d
            self.macro_new_fmclp_dataset(t_min_us=t_min_us, t_max_us=t_max_us)

            # Enable interactive widgets associated with the b-scan plots and iso-t plot:
            self.enable_interactive_widgets_b_scans_and_iso_t()

            # Enable add TFM button:
            self.pushButton_add_tfm_image.setEnabled(True)

    def request_file_import_params(self):
        # Open a dialog to request the file import parameters:
        dialog_file_import_params = DialogImportFMCLPmat(parent=self)
        dialog_file_import_params.exec()
        # When the dialog has either been accepted or rejected:
        # Boolean showing whether the user clicked 'accept' or 'cancel':
        provided = dialog_file_import_params.result()
        # Other parameters:
        description = dialog_file_import_params.description_string
        file_path = dialog_file_import_params.file_path
        t_min = dialog_file_import_params.t_min_us
        t_max = dialog_file_import_params.t_max_us
        detrend_tf = dialog_file_import_params.checkBox_detrend.isChecked()

        return provided, description, file_path, t_min, t_max, detrend_tf

    def request_tfm_params(self):
        # Open a dialog to request the TFM parameters:
        dialog_tfm_params = DialogTFMParamsFMCLP(parent=self, tfm_params_previous=self.tfm_params_previous)
        dialog_tfm_params.exec()
        # When the dialog has either been accepted or rejected:
        # Boolean showing whether the user clicked 'accept' or 'cancel':
        accepted = dialog_tfm_params.result()
        # If accepted, dialog.tfm_params will be a TFMParams object containing all the parameters needed.
        # If rejected, dialog.tfm_params will return 'None'.
        tfm_params = dialog_tfm_params.tfm_params
        # Update the 'previous' tfm params for use if the dialog is called again:
        self.tfm_params_previous = tfm_params
        return accepted, tfm_params

    def update_iso_det_plot(self):
        # Update B-scan colormap:
        b_scan_iso_det = self.fmc_3d_displayed[:, self.det_index, :]
        self.b_scan_view_widget_iso_det.update_b_scan_display(b_scan_iso_det)
        # If a pixel is selected, update the delays shown:
        if self.selected_tfm_image and self.selected_tfm_image.complete and self.pixel_selected:
            delay_vector_iso_det = self.delay_matrix_s[self.det_index, :]
            self.b_scan_view_widget_iso_det.update_delays(delay_vector_iso_det)

    def update_iso_gen_plot(self):
        b_scan_iso_gen = self.fmc_3d_displayed[:, :, self.gen_index]
        self.b_scan_view_widget_iso_gen.update_b_scan_display(b_scan_iso_gen)
        # If a pixel is selected, update the delays shown:
        if self.selected_tfm_image and self.selected_tfm_image.complete and self.pixel_selected:
            delay_vector_iso_gen = self.delay_matrix_s[:, self.gen_index]
            self.b_scan_view_widget_iso_gen.update_delays(delay_vector_iso_gen)

    def update_iso_time_plot(self):
        iso_time_slice = self.fmc_3d_displayed[self.time_index, :, :]
        self.iso_time_plot_widget.update_iso_time_slice_display(iso_time_slice)
        # If a pixel is selected, update the highlighted nearest A-scans:
        if self.selected_tfm_image and self.selected_tfm_image.complete and self.pixel_selected:
            self.iso_time_plot_widget.update_nearest_a_scans(self.delay_matrix_s,
                                                             self.time_vector_us[self.time_index])

    def disable_sliders(self):
        self.slider_det_index.setEnabled(False)
        self.slider_gen_index.setEnabled(False)
        self.slider_time_index.setEnabled(False)
        self.slider_dB_min.setEnabled(False)

    def create_time_vector(self, t_min_us, t_max_us):
        # Create an evenly spaced time vector using the min and max time values:
        self.time_vector_us = np.linspace(t_min_us, t_max_us, self.n_samples, endpoint=True)
        # Save the sampling period in us:
        self.sampling_period_us = (t_max_us - t_min_us) / (self.n_samples - 1)
        # Save t_min and t_max for use in time indexing:
        self.t_min_us = t_min_us
        self.t_max_us = t_max_us

    def macro_new_fmclp_dataset(self, t_min_us, t_max_us):
        # Update the values inferred from the shape of the fmc A-scan matrix:
        self.n_samples, self.n_tx, _ = np.shape(self.fmc_3d)

        # Create a new time vector:
        self.create_time_vector(t_min_us, t_max_us)

        # Update plot axes based on n_tx:
        self.b_scan_view_widget_iso_det.update_axes(self.n_tx, t_min_us, t_max_us)
        self.b_scan_view_widget_iso_gen.update_axes(self.n_tx, t_min_us, t_max_us)
        self.iso_time_plot_widget.update_axes(self.n_tx)
        if self.pcm_viewer_widget:
            self.pcm_viewer_widget.update_axes(self.n_tx)
            self.pcm_viewer_widget.re_draw_mplcanvas()
        if self.cheops_viewer_widget:
            self.cheops_viewer_widget.update_axes(self.n_tx, t_min_us, t_max_us)
            self.cheops_viewer_widget.mpl_canvas.draw()

        # Update and re-set controls (sliders and spin boxes) for time, gen and det indices:
        self.update_and_reset_time_gen_det_controls(t_min_us, t_max_us)

        # Visualise the FMC on the plots:
        # Use min and max to set colormaps:
        self.set_colormap_limits_to_data_min_and_max()
        # Update displayed data:
        self.update_iso_det_plot()
        self.b_scan_view_widget_iso_det.mpl_canvas.draw()
        self.update_iso_gen_plot()
        self.b_scan_view_widget_iso_gen.mpl_canvas.draw()
        self.update_iso_time_plot()
        self.iso_time_plot_widget.mpl_canvas.draw()

    def update_and_reset_time_gen_det_controls(self, t_min_us, t_max_us):
        # Update step for time navigation via the doubleSpinBox:
        self.update_time_spinbox_step(t_min_us, t_max_us)
        # Update time doubleSpinBox limits:
        self.update_time_spinbox_limits(t_min_us, t_max_us)
        # Update slider limits:
        self.update_slider_limits()
        # Update gen and det index spinbox limits:
        self.update_gen_and_det_spinbox_limits()
        # Re-set time, gen and det indices:
        self.reset_time_gen_and_det_values(t_min_us)

    def update_time_spinbox_step(self, t_min_us, t_max_us):
        # Calculate step size based on time min, max and n_samples:
        time_step_us = (t_max_us - t_min_us) / (self.n_samples - 1)
        # Set as step size for time doubleSpinBox:
        self.doubleSpinBox_time_us.setSingleStep(time_step_us)

    def update_time_spinbox_limits(self, t_min_us, t_max_us):
        self.doubleSpinBox_time_us.setMinimum(t_min_us)
        self.doubleSpinBox_time_us.setMaximum(t_max_us)

    def update_slider_limits(self):
        # Update slider limits:
        # Remember, Python is zero-indexed.  The first element is element 0, and the last is element n_tx-1.
        self.slider_det_index.setMaximum(self.n_tx - 1)
        self.slider_gen_index.setMaximum(self.n_tx - 1)
        self.slider_time_index.setMaximum(self.n_samples - 1)

    def update_gen_and_det_spinbox_limits(self):
        # Python is zero-indexed: gen and det indices go from 0 to (n_tx - 1):
        self.spinBox_gen_index.setMaximum(self.n_tx - 1)
        self.spinBox_det_index.setMaximum(self.n_tx - 1)

    def reset_time_gen_and_det_values(self, t_min_us):
        # Set time to the minimum of the new time vector, without emitting signals:
        self.time_index = 0
        self.slider_time_index.blockSignals(True)
        self.slider_time_index.setValue(0)
        self.slider_time_index.blockSignals(False)
        self.doubleSpinBox_time_us.blockSignals(True)
        self.doubleSpinBox_time_us.setValue(t_min_us)
        self.doubleSpinBox_time_us.blockSignals(False)

        # Set gen and det indices to 0, without emitting signals:
        self.slider_gen_index.blockSignals(True)
        self.slider_gen_index.setValue(0)
        self.slider_gen_index.blockSignals(False)
        self.slider_det_index.blockSignals(True)
        self.slider_det_index.setValue(0)
        self.slider_det_index.blockSignals(False)
        self.spinBox_gen_index.blockSignals(True)
        self.spinBox_gen_index.setValue(0)
        self.spinBox_gen_index.blockSignals(False)
        self.spinBox_det_index.blockSignals(True)
        self.spinBox_det_index.setValue(0)
        self.spinBox_det_index.blockSignals(False)

    def c_min_changed(self, c_min_mv):
        self.c_min_mv = c_min_mv
        self.set_c_min_for_all_widgets(c_min_mv)
        self.update_raw_cdata_images()

    def c_max_changed(self, c_max_mv):
        self.c_max_mv = c_max_mv
        self.set_c_max_for_all_widgets(c_max_mv)
        self.update_raw_cdata_images()

    def set_c_min_for_all_widgets(self, c_min_mv):
        self.iso_time_plot_widget.axes_image.set_clim(vmin=c_min_mv * 10 ** -3)
        self.b_scan_view_widget_iso_det.axes_image.set_clim(vmin=c_min_mv * 10 ** -3)
        self.b_scan_view_widget_iso_gen.axes_image.set_clim(vmin=c_min_mv * 10 ** -3)
        if self.pcm_viewer_widget:
            self.pcm_viewer_widget.new_c_min(c_min_mv)

    def set_c_max_for_all_widgets(self, c_max_mv):
        self.iso_time_plot_widget.axes_image.set_clim(vmax=c_max_mv * 10 ** -3)
        self.b_scan_view_widget_iso_det.axes_image.set_clim(vmax=c_max_mv * 10 ** -3)
        self.b_scan_view_widget_iso_gen.axes_image.set_clim(vmax=c_max_mv * 10 ** -3)
        if self.pcm_viewer_widget:
            self.pcm_viewer_widget.new_c_max(c_max_mv)

    def set_colormap_limits_to_data_min_and_max(self):
        # Set the colormap limits to be the extreme min and max of the dataset:
        c_min_mv = np.min(self.fmc_3d_displayed) / 10 ** -3
        c_max_mv = np.max(self.fmc_3d_displayed) / 10 ** -3
        self.c_min_mv = c_min_mv
        self.c_max_mv = c_max_mv
        self.set_c_min_for_all_widgets(c_min_mv)
        self.set_c_max_for_all_widgets(c_max_mv)

        # Display the new colormap limits in the spinBoxes:
        self.doubleSpinBox_c_min.setValue(c_min_mv)
        self.doubleSpinBox_c_max.setValue(c_max_mv)

    def update_raw_cdata_images(self):
        self.iso_time_plot_widget.blit_manager.blit_all_animated_artists()
        self.b_scan_view_widget_iso_det.blit_manager.blit_all_animated_artists()
        self.b_scan_view_widget_iso_gen.blit_manager.blit_all_animated_artists()
        if self.pcm_viewer_widget:
            self.pcm_viewer_widget.re_draw_pcm_mplcanvas()

    def disable_tfm_buttons(self):
        self.pushButton_add_tfm_image.setEnabled(False)
        self.pushButton_delete_tfm_image.setEnabled(False)

    def add_tfm_button_clicked(self):
        # Open a dialog to request a new set of TFM parameters from the user:
        accepted, tfm_params = self.request_tfm_params()

        if accepted:
            self.run_tfm_job(tfm_params)

    def run_tfm_job(self, tfm_params):
        # When the user submits their new TFM parameters, we need to start a QRunnable to compute the TFM:
        tfm_worker = TFMWorker(fmc_3d=self.fmc_3d, tfm_params=tfm_params, time_vector_us=self.time_vector_us)

        # Wire the signals emitted by the parallel operation to slots:
        tfm_worker.signals.progress.connect(self.worker_progress_detected)
        tfm_worker.signals.result.connect(self.worker_result_detected)
        tfm_worker.signals.finished.connect(self.worker_finished_detected)

        # Create a new instance of ListedTFMImage and add it to the list model:
        self.list_model_tfm_images.dict_listed_images[tfm_worker.worker_id] = ListedTFMImage(tfm_worker.worker_id,
                                                                                             tfm_params, self.n_tx)

        # Run the TFM_worker in the threadpool:
        self.threadpool.start(tfm_worker)

    def worker_progress_detected(self, data_tuple):
        # A worker has transmitted the 'progress' signal.  The data_tuple contains two elements:
        worker_id, progress_string = data_tuple

        # Update the progress_string of the associated ListedTFMImage instance:
        self.list_model_tfm_images.dict_listed_images[worker_id].progress_string = progress_string

        # Trigger the ListView to update:
        self.list_model_tfm_images.layoutChanged.emit()

    def worker_result_detected(self, data_tuple):
        # A worker has transmitted the 'result' signal.  The data_tuple contains two elements:
        worker_id, image_decibels, fmc_3d_filtered = data_tuple

        # Pin the returned image data & filtered FMC to the associated ListenTFMImage instance:
        self.list_model_tfm_images.dict_listed_images[worker_id].image_decibels = image_decibels
        self.list_model_tfm_images.dict_listed_images[worker_id].fmc_3d_filtered = fmc_3d_filtered

    def worker_finished_detected(self, worker_id):
        # A worker has transmitted the 'finished' signal.
        # Call the 'completed()' method for the associated ListedTFMImage instance:
        self.list_model_tfm_images.dict_listed_images[worker_id].completed()

        # Trigger the ListView to update:
        self.list_model_tfm_images.layoutChanged.emit()

    def tfm_image_list_view_selection_changed(self, item_selection):
        # The selection could be 'None':
        if item_selection:
            # A valid index with a corresponding ListedTFMImage instance has been selected:
            indexes = item_selection.indexes()
            index = indexes[0]
            # Use 'index' to obtain the key (worker ID) for the selected TFM image:
            key = list(self.list_model_tfm_images.dict_listed_images.keys())[index.row()]
            self.selected_tfm_image = self.list_model_tfm_images.dict_listed_images[key]

            if self.selected_tfm_image.complete:
                self.complete_tfm_image_selected()
            else:
                self.clear_and_deactivate_tfm_image_area()
        else:
            # The selection has changed to 'None':
            self.clear_and_deactivate_tfm_image_area()

    def complete_tfm_image_selected(self):
        # The user has clicked on a complete TFM image:

        # Clear the pixel selection and delay laws:
        if self.pixel_selected:
            self.clear_pixel_selection()
            # Clear delay times & hide delay markers on raw data plots:
            self.b_scan_view_widget_iso_det.clear_delay_times_and_hide()
            self.b_scan_view_widget_iso_det.blit_manager.blit_all_animated_artists()
            self.b_scan_view_widget_iso_gen.clear_delay_times_and_hide()
            self.b_scan_view_widget_iso_gen.blit_manager.blit_all_animated_artists()
            self.iso_time_plot_widget.clear_nearest_a_scan_highlights_and_hide()
            self.iso_time_plot_widget.blit_manager.blit_all_animated_artists()
            if self.cheops_viewer_widget:
                self.cheops_viewer_widget.hide_cheops_pyramid()

        # Display the image in decibels on the tfm image plot:
        # Update the axis limits:
        self.tfm_image_widget_2D.update_axes_centred(self.selected_tfm_image.tfm_params.grid_size_x_mm,
                                                     self.selected_tfm_image.tfm_params.grid_size_z_mm)
        # Transmit the cdata:
        self.tfm_image_widget_2D.axes_image.set_data(self.selected_tfm_image.image_decibels)
        # Reset the colormap limits:
        self.tfm_image_widget_2D.axes_image.set_clim(vmin=self.decibel_minimum)
        # Draw the TFM image:
        self.tfm_image_widget_2D.mpl_canvas.draw()

        # If the selected TFM image used filtering, display the filtered FMC on the B-scan and iso-time widgets:
        if self.selected_tfm_image.tfm_params.filter_tf:
            self.macro_swap_displayed_fmc(self.selected_tfm_image.fmc_3d_filtered)
            # Enable the 'display unfiltered' button:
            self.pushButton_display_unfiltered.setEnabled(True)
        else:
            # The selected TFM image did not use filtering.
            # Display the original, unfiltered FMC:
            self.macro_swap_displayed_fmc(self.fmc_3d)
            # Disable the 'display unfiltered' button:
            self.pushButton_display_unfiltered.setEnabled(False)

        if self.decibel_minimum == 0:
            # Set decibel_minimum back to its default value of -10dB:
            self.decibel_minimum = -10
        # Display the current decibel minimum value in the slider and spinbox:
        # Remember: the slider is inverted for aesthetic reasons, and takes positive values of the dB min:
        self.slider_dB_min.setValue(abs(self.decibel_minimum))
        self.doubleSpinBox_dB_min.setValue(self.decibel_minimum)

        # Transmit the tfm_params for this TFM image to the tfm_image_widget for use in pretty printing:
        self.tfm_image_widget_2D.tfm_params = self.selected_tfm_image.tfm_params

        # Enable the dB min slider and spinbox:
        self.slider_dB_min.setEnabled(True)
        self.doubleSpinBox_dB_min.setEnabled(True)

        # Enable the 'delete tfm image' button:
        self.pushButton_delete_tfm_image.setEnabled(True)

    def clear_and_deactivate_tfm_image_area(self):
        # The user has clicked on a TFM image that is still processing:
        # Display nothing on the TFM image plot:
        self.tfm_image_widget_2D.display_default_image()
        self.clear_pixel_selection()
        self.tfm_image_widget_2D.redraw()
        # Display zero on the dB slider and spin box (this also sets self.decibel_minimum to zero):
        self.slider_dB_min.setValue(0)
        self.doubleSpinBox_dB_min.setValue(0)
        # Disable the dB min slider and spinbox:
        self.slider_dB_min.setEnabled(False)
        self.doubleSpinBox_dB_min.setEnabled(False)
        # Disable the delete tfm image button:
        self.pushButton_delete_tfm_image.setEnabled(False)

    def clear_pixel_selection(self):
        self.tfm_image_widget_2D.clear_pixel_cursor()
        self.pixel_selected = False

    def decibel_min_changed_by_slider(self, minus_decibel_minimum):
        # The slider outputs positive values, which need to be converted to negative:
        decibel_minimum = - minus_decibel_minimum
        # Display the new value in the spinbox, without emitting signals:
        self.doubleSpinBox_dB_min.blockSignals(True)
        self.doubleSpinBox_dB_min.setValue(decibel_minimum)
        self.doubleSpinBox_dB_min.blockSignals(False)
        # Call the generic dB min changed function:
        self.decibel_min_changed(decibel_minimum)

    def decibel_min_changed_by_spinbox(self, decibel_minimum):
        # Display the new value on the slider, without emitting signals:
        self.slider_dB_min.blockSignals(True)
        self.slider_dB_min.setValue(abs(self.decibel_minimum))
        self.slider_dB_min.blockSignals(False)
        # Call the generic dB min changed function:
        self.decibel_min_changed(decibel_minimum)

    def decibel_min_changed(self, decibel_minimum):
        # Pin the new value to self:
        self.decibel_minimum = decibel_minimum
        # Change the v_min parameter of the TFM image plot:
        self.tfm_image_widget_2D.axes_image.set_clim(vmin=self.decibel_minimum)
        # Blit the new RGB image:
        self.tfm_image_widget_2D.blit_manager.blit_all_animated_artists()

    def macro_swap_displayed_fmc(self, fmc_3d):
        # Swap the c_data on the B-scan widgets and iso-time widgets:
        # Update the fmc used for display:
        self.fmc_3d_displayed = fmc_3d
        # Update the c_data on the B-scan plots and iso-time plot:
        self.update_iso_det_plot()
        self.b_scan_view_widget_iso_det.blit_manager.blit_all_animated_artists()
        self.update_iso_gen_plot()
        self.b_scan_view_widget_iso_gen.blit_manager.blit_all_animated_artists()
        self.update_iso_time_plot()
        self.iso_time_plot_widget.blit_manager.blit_all_animated_artists()

    def button_display_unfiltered_toggled(self, checked):
        if checked:
            # Display the unfiltered FMC:
            self.macro_swap_displayed_fmc(self.fmc_3d)
        else:
            # Display the filtered FMC:
            self.macro_swap_displayed_fmc(self.selected_tfm_image.fmc_3d_filtered)

    def enable_interactive_widgets_b_scans_and_iso_t(self):
        self.slider_det_index.setEnabled(True)
        self.slider_gen_index.setEnabled(True)
        self.slider_time_index.setEnabled(True)
        self.doubleSpinBox_c_min.setEnabled(True)
        self.doubleSpinBox_c_max.setEnabled(True)
        self.doubleSpinBox_time_us.setEnabled(True)
        self.spinBox_gen_index.setEnabled(True)
        self.spinBox_det_index.setEnabled(True)

    def delete_scan_button_pressed(self):
        # Delete the data associated with the selected tfm image, if there is one selected and it is 'complete':
        if self.selected_tfm_image:
            if self.selected_tfm_image.complete:
                # Ask the user for confirmation with a dialog:
                # Get the display string of the selected TFM image to use in the question:
                selected_image_name = self.selected_tfm_image.get_display_string()
                button_chosen = QMessageBox.question(self, 'Confirm delete',
                                                     f'Are you sure you want to delete {selected_image_name}?')

                if button_chosen == QMessageBox.Yes:
                    # Delete the corresponding ListedTFMImage instance in the model dictionary:
                    key = self.selected_tfm_image.worker_id
                    del self.list_model_tfm_images.dict_listed_images[key]
                    # Emit the 'layout changed' signal from the list model to prompt the list view to update:
                    self.list_model_tfm_images.layoutChanged.emit()
                    # Clear the selection model of the ListView:
                    self.listView_tfm_images.clearSelection()
                else:
                    # The user changed their mind and no longer wants to delete the selected TFM image.
                    pass

    def new_pixel_clicked(self, xz_coords_m_tuple):
        # Store pixel co-ordinates:
        self.pixel_coords_tuple_m = xz_coords_m_tuple
        # Only calculate & display delay laws for this pixel if there is currently a valid selected listed TFM image:
        if self.selected_tfm_image.complete:
            x_pixel_m, z_pixel_m = xz_coords_m_tuple
            self.pixel_selected = True
            # Calculate the delay law associated with this pixel:
            # Which wave set is associated with the current TFM image?
            wave_set_string = self.selected_tfm_image.tfm_params.wave_set_string
            # Get the delay law function for this wave set:
            calculate_delay_law = dict_wave_sets[wave_set_string].delay_law_function
            # Call the delay law function and return an n_tx by n_tx matrix of delays:
            self.delay_matrix_s = calculate_delay_law(x_pixel_m, z_pixel_m,
                                                      self.selected_tfm_image.x_gen_matrix_m,
                                                      self.selected_tfm_image.x_det_matrix_m,
                                                      self.selected_tfm_image.angle_critical_radians,
                                                      self.selected_tfm_image.tfm_params.v_l_mpers,
                                                      self.selected_tfm_image.tfm_params.v_t_mpers)
            # Mask delay law or color if polarity flipping:
            if self.selected_tfm_image.tfm_params.gen_mask_tf:
                #if self.selected_tfm_image.tfm_params.apply_mask_during_summing:
                # Apply mask to the delay matrix based on send ray angle:
                gen_angle_matrix_deg = calculate_gen_angle_matrix_deg(x_pixel_m, z_pixel_m,
                                                                      self.selected_tfm_image.x_gen_matrix_m)
                # Use chosen mask behaviour:
                mask_behaviour = dict_mask_behaviours[self.selected_tfm_image.tfm_params.mask_behaviour_string]
                numpy_masking_function = mask_behaviour.numpy_masking_function
                gen_angle_matrix_masked = numpy_masking_function(gen_angle_matrix_deg,
                                                                 self.selected_tfm_image.tfm_params.mask_angle_deg)
                self.delay_matrix_s = np.ma.masked_where(np.ma.getmaskarray(gen_angle_matrix_masked),
                                                         self.delay_matrix_s)

            # Display the delays on the B-scan widgets:
            self.b_scan_view_widget_iso_det.update_delays(self.delay_matrix_s[self.det_index, :])
            self.b_scan_view_widget_iso_det.make_delays_visible()
            self.b_scan_view_widget_iso_det.blit_manager.blit_all_animated_artists()
            self.b_scan_view_widget_iso_gen.update_delays(self.delay_matrix_s[:, self.gen_index])
            self.b_scan_view_widget_iso_gen.make_delays_visible()
            self.b_scan_view_widget_iso_gen.blit_manager.blit_all_animated_artists()

            # Highlight the A-scans whose delays are closest to the current viewing time on the iso-time widget:
            self.iso_time_plot_widget.update_nearest_a_scans(self.delay_matrix_s,
                                                             self.time_vector_us[self.time_index])
            self.iso_time_plot_widget.make_nearest_a_scans_visible()
            self.iso_time_plot_widget.blit_manager.blit_all_animated_artists()

            # If the pcm viewer is open, compute the pcm and update the data displayed in the PCM viewer:
            if self.pcm_viewer_widget:
                # The widget exists.
                self.update_pcm_viewer_data()

            # If the Cheops viewer widget is open, display the Cheops pyramid associated with the selected pixel:
            if self.cheops_viewer_widget:
                self.cheops_viewer_widget.update_cheops_pyramid(self.delay_matrix_s)
                self.cheops_viewer_widget.mpl_canvas.draw()

    def shortcut_ctrl_n_activated(self):
        # If a pixel is selected, toggle delay law visibility on the b-scan and iso-t plots:
        if self.pixel_selected:
            self.b_scan_view_widget_iso_det.toggle_delay_visibility()
            self.b_scan_view_widget_iso_det.blit_manager.blit_all_animated_artists()
            self.b_scan_view_widget_iso_gen.toggle_delay_visibility()
            self.b_scan_view_widget_iso_gen.blit_manager.blit_all_animated_artists()
            self.iso_time_plot_widget.toggle_nearest_a_scans_visibility()
            self.iso_time_plot_widget.blit_manager.blit_all_animated_artists()

    def toggle_pcm_viewer(self):
        if self.pcm_viewer_widget:
            # The widget already exists.  Close it:
            self.pcm_viewer_widget.close()
            # Set Python reference to None:
            self.pcm_viewer_widget = None
        else:
            # The widget is not already open.  Create a new instance & show it:
            self.pcm_viewer_widget = PCMViewer()
            # Wire signals to slots:
            self.pcm_viewer_widget.pcm_viewer_closed.connect(self.slot_pcm_viewer_closed)
            # If there is a pixel selected, display the data associated with that pixel:
            if self.pixel_selected:
                self.update_pcm_viewer_data()
            # Set the colormap limits for the PCM image:
            self.pcm_viewer_widget.new_c_min(self.c_min_mv)
            self.pcm_viewer_widget.new_c_max(self.c_max_mv)
            # Set axes extent based on n_tx of loaded data:
            self.pcm_viewer_widget.update_axes(self.n_tx)
            # Open the window:
            self.pcm_viewer_widget.show()

    def slot_pcm_viewer_closed(self):
        self.action_toggle_pcm_viewer.setChecked(False)
        # Set Python reference to None:
        self.pcm_viewer_widget = None

    def update_pcm_viewer_data(self):
        # Extract the pixel contributions matrix:
        pcm = extract_pcm(self.fmc_3d_displayed, self.time_vector_us, self.delay_matrix_s)
        # Update all data in the pcm viewer window:
        self.pcm_viewer_widget.macro_new_pixel_clicked(pcm,
                                                       self.pixel_coords_tuple_m[0], self.pixel_coords_tuple_m[1],
                                                       self.selected_tfm_image.angle_critical_radians,
                                                       self.selected_tfm_image.tfm_params.pitch_mm,
                                                       self.n_tx)
        # Trigger a re-draw of the pcm viewer mpl canvases:
        self.pcm_viewer_widget.re_draw_pcm_mplcanvas()

    def toggle_cheops_viewer(self):
        if self.cheops_viewer_widget:
            # The widget already exists.  Close it:
            self.cheops_viewer_widget.close()
            # Set Python reference to None:
            self.cheops_viewer_widget = None
        else:
            # The widget is not already open.  Create a new instance & show it:
            self.cheops_viewer_widget = CheopsViewer(self.n_tx, self.t_min_us, self.t_max_us, self.time_us,
                                                     self.delay_matrix_s)
            # Wire signals to slots:
            self.cheops_viewer_widget.cheops_viewer_closed.connect(self.slot_cheops_viewer_closed)
            # If there is a pixel selected, display the data associated with that pixel:
            if self.pixel_selected:
                self.update_cheops_viewer_data()
            # Open the window:
            self.cheops_viewer_widget.show()

    def update_cheops_viewer_data(self):
        pass

    def slot_cheops_viewer_closed(self):
        self.action_toggle_cheops_viewer.setChecked(False)
        # Set Python reference to None:
        self.cheops_viewer_widget = None

    def update_cheops_pyramid(self, delay_matrix_us):
        self.cheops_viewer_widget.update_cheops_pyramid(self, delay_matrix_us)
        self.cheops_viewer_widget.mpl_canvas.draw()
